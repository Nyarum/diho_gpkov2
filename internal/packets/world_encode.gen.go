// Code generated by diho_bytes_generate world.go; DO NOT EDIT.

package packets

import (
	"context"
	"encoding/binary"
	utils "github.com/Nyarum/diho_bytes_generate/utils"
	bytebufferpool "github.com/valyala/bytebufferpool"
)

func (p *CharacterBoat) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	if encodeBuf, err := p.CharacterBase.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.CharacterAttribute.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.CharacterKitbag.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.CharacterSkillState.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	return utils.Clone(newBuf), nil
}
func (p *Shortcut) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.Type)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.GridID)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterShortcut) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	for _, v := range p.Shortcuts {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *KitbagItem) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.GridID)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "GridID") == true {
		return utils.Clone(newBuf), nil
	}
	err = binary.Write(newBuf, endian, p.ID)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "ID") == true {
		return utils.Clone(newBuf), nil
	}
	err = binary.Write(newBuf, endian, p.Num)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "Num") == true {
		return utils.Clone(newBuf), nil
	}
	for _, v := range p.Endure {
		if err = binary.Write(newBuf, endian, v); err != nil {
			return nil, err
		}
	}
	if p.Filter(ctx, "Endure") == true {
		return utils.Clone(newBuf), nil
	}
	for _, v := range p.Energy {
		if err = binary.Write(newBuf, endian, v); err != nil {
			return nil, err
		}
	}
	if p.Filter(ctx, "Energy") == true {
		return utils.Clone(newBuf), nil
	}
	err = binary.Write(newBuf, endian, p.ForgeLevel)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "ForgeLevel") == true {
		return utils.Clone(newBuf), nil
	}
	err = binary.Write(newBuf, endian, p.IsValid)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "IsValid") == true {
		return utils.Clone(newBuf), nil
	}
	if p.ID == 3988 {
		err = binary.Write(newBuf, endian, p.ItemDBInstID)
		if err != nil {
			return nil, err
		}
	}
	if p.Filter(ctx, "ItemDBInstID") == true {
		return utils.Clone(newBuf), nil
	}
	err = binary.Write(newBuf, endian, p.ItemDBForge)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "ItemDBForge") == true {
		return utils.Clone(newBuf), nil
	}
	if p.ID == 3988 {
		err = binary.Write(newBuf, endian, p.BoatNull)
		if err != nil {
			return nil, err
		}
	}
	if p.Filter(ctx, "BoatNull") == true {
		return utils.Clone(newBuf), nil
	}
	if p.ID != 3988 {
		err = binary.Write(newBuf, endian, p.ItemDBInstID2)
		if err != nil {
			return nil, err
		}
	}
	if p.Filter(ctx, "ItemDBInstID2") == true {
		return utils.Clone(newBuf), nil
	}
	err = binary.Write(newBuf, endian, p.IsParams)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "IsParams") == true {
		return utils.Clone(newBuf), nil
	}
	for _, v := range p.InstAttrs {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	if p.Filter(ctx, "InstAttrs") == true {
		return utils.Clone(newBuf), nil
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterKitbag) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.Type)
	if err != nil {
		return nil, err
	}
	if p.Type == SYN_KITBAG_INIT {
		err = binary.Write(newBuf, endian, p.KeybagNum)
		if err != nil {
			return nil, err
		}
	}
	for _, v := range p.Items {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *Attribute) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.ID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Value)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterAttribute) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.Type)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Num)
	if err != nil {
		return nil, err
	}
	for _, v := range p.Attributes {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *SkillState) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.ID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Level)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterSkillState) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.StatesLen)
	if err != nil {
		return nil, err
	}
	for _, v := range p.States {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterSkill) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.ID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.State)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Level)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.UseSP)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.UseEndure)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.UseEnergy)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.ResumeTime)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.RangeType)
	if err != nil {
		return nil, err
	}
	for _, v := range p.Params {
		if err = binary.Write(newBuf, endian, v); err != nil {
			return nil, err
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterSkillBag) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.SkillID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Type)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.SkillNum)
	if err != nil {
		return nil, err
	}
	for _, v := range p.Skills {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterAppendLook) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.LookID)
	if err != nil {
		return nil, err
	}
	if p.LookID != 0 {
		err = binary.Write(newBuf, endian, p.IsValid)
		if err != nil {
			return nil, err
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterPK) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.PkCtrl)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterLookBoat) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.PosID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.BoatID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Header)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Body)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Engine)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Cannon)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Equipment)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterLookItemSync) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.Endure)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Energy)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.IsValid)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterLookItemShow) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.Num)
	if err != nil {
		return nil, err
	}
	for _, v := range p.Endure {
		if err = binary.Write(newBuf, endian, v); err != nil {
			return nil, err
		}
	}
	for _, v := range p.Energy {
		if err = binary.Write(newBuf, endian, v); err != nil {
			return nil, err
		}
	}
	err = binary.Write(newBuf, endian, p.ForgeLevel)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.IsValid)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterLookItem) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.ID)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "ID") == true {
		return utils.Clone(newBuf), nil
	}
	if p.SynType == SynLookChange {
		if encodeBuf, err := p.ItemSync.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	if p.Filter(ctx, "ItemSync") == true {
		return utils.Clone(newBuf), nil
	}
	if p.SynType == SynLookSwitch {
		if encodeBuf, err := p.ItemShow.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	if p.Filter(ctx, "ItemShow") == true {
		return utils.Clone(newBuf), nil
	}
	err = binary.Write(newBuf, endian, p.IsDBParams)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "IsDBParams") == true {
		return utils.Clone(newBuf), nil
	}
	for _, v := range p.DBParams {
		if err = binary.Write(newBuf, endian, v); err != nil {
			return nil, err
		}
	}
	if p.Filter(ctx, "DBParams") == true {
		return utils.Clone(newBuf), nil
	}
	err = binary.Write(newBuf, endian, p.IsInstAttrs)
	if err != nil {
		return nil, err
	}
	if p.Filter(ctx, "IsInstAttrs") == true {
		return utils.Clone(newBuf), nil
	}
	for _, v := range p.InstAttrs {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	if p.Filter(ctx, "InstAttrs") == true {
		return utils.Clone(newBuf), nil
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterLookHuman) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.HairID)
	if err != nil {
		return nil, err
	}
	for _, v := range p.ItemGrid {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterLook) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.SynType)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.TypeID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.IsBoat)
	if err != nil {
		return nil, err
	}
	if p.IsBoat == 1 {
		if encodeBuf, err := p.LookBoat.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	if p.IsBoat == 0 {
		if encodeBuf, err := p.LookHuman.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *EntityEvent) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.EntityID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.EntityType)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.EventID)
	if err != nil {
		return nil, err
	}
	err = utils.WriteStringNull(newBuf, p.EventName)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterSide) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.SideID)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *Position) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.X)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Y)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Radius)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *CharacterBase) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.ChaID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.WorldID)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.CommID)
	if err != nil {
		return nil, err
	}
	err = utils.WriteStringNull(newBuf, p.CommName)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.GmLvl)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Handle)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.CtrlType)
	if err != nil {
		return nil, err
	}
	err = utils.WriteStringNull(newBuf, p.Name)
	if err != nil {
		return nil, err
	}
	err = utils.WriteStringNull(newBuf, p.MottoName)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.Icon)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.GuildID)
	if err != nil {
		return nil, err
	}
	err = utils.WriteStringNull(newBuf, p.GuildName)
	if err != nil {
		return nil, err
	}
	err = utils.WriteStringNull(newBuf, p.GuildMotto)
	if err != nil {
		return nil, err
	}
	err = utils.WriteStringNull(newBuf, p.StallName)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.State)
	if err != nil {
		return nil, err
	}
	if encodeBuf, err := p.Position.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	err = binary.Write(newBuf, endian, p.Angle)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.TeamLeaderID)
	if err != nil {
		return nil, err
	}
	if encodeBuf, err := p.Side.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.EntityEvent.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.Look.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.PkCtrl.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	for _, v := range p.LookAppend {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	return utils.Clone(newBuf), nil
}
func (p *EnterGame) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = binary.Write(newBuf, endian, p.EnterRet)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.AutoLock)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.KitbagLock)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.EnterType)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.IsNewChar)
	if err != nil {
		return nil, err
	}
	err = utils.WriteStringNull(newBuf, p.MapName)
	if err != nil {
		return nil, err
	}
	err = binary.Write(newBuf, endian, p.CanTeam)
	if err != nil {
		return nil, err
	}
	if encodeBuf, err := p.CharacterBase.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.CharacterSkillBag.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.CharacterSkillState.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.CharacterAttribute.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.CharacterKitbag.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	if encodeBuf, err := p.CharacterShortcut.Encode(ctx, endian); err != nil {
		return nil, err
	} else {
		newBuf.Write(encodeBuf)
	}
	err = binary.Write(newBuf, endian, p.BoatLen)
	if err != nil {
		return nil, err
	}
	for _, v := range p.CharacterBoats {
		if encodeBuf, err := v.Encode(ctx, endian); err != nil {
			return nil, err
		} else {
			newBuf.Write(encodeBuf)
		}
	}
	err = binary.Write(newBuf, endian, p.ChaMainID)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
func (p *EnterGameRequest) Encode(ctx context.Context, endian binary.ByteOrder) ([]byte, error) {
	newBuf := bytebufferpool.Get()
	defer bytebufferpool.Put(newBuf)
	var err error
	err = utils.WriteStringNull(newBuf, p.CharacterName)
	if err != nil {
		return nil, err
	}
	return utils.Clone(newBuf), nil
}
